<!-- 
 ******************************************************************************
 * Copyright (c) 2013 Oracle and Liferay
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/epl-v10.html
 *
 * Contributors:
 *    Konstantin Komissarchik - initial implementation and ongoing maintenance
 *    Gregory Amerson - [363551] JavaTypeConstraintService
 *    Gregory Amerson - [372359] Provide means to extend the behavior of adapt methods
 *    Gregory Amerson - [358295] Need access to selection in list property editor
 ******************************************************************************
-->

<html>

<head>
  <title>Sapphire Services</title>
  <link rel="StyleSheet" href="../style.css" TYPE="text/css"/>
</head>

<body>

<h1>Services</h1>

<p>Many aspects of Sapphire can be extended by third parties.</p>

<ul>
  <li><a href="#AdapterService">AdapterService</a></li>
  <li><a href="#ContentProposalService">ContentProposalService</a></li>
  <li><a href="#ConversionService">ConversionService</a></li>
  <li><a href="#DependenciesAggregationService">DependenciesAggregationService</a></li>
  <li><a href="#DependenciesService">DependenciesService</a></li>
  <li><a href="#DiagramLayoutPersistenceService">DiagramLayoutPersistenceService</a></li>
  <li><a href="#DragAndDropService">DragAndDropService</a></li>  
  <li><a href="#EqualityService">EqualityService</a></li>
  <li><a href="#FactsAggregationService">FactsAggregationService</a></li>
  <li><a href="#FactsService">FactsService</a></li>
  <li><a href="#FileExtensionsService">FileExtensionsService</a></li>
  <li><a href="#InitialValueService">InitialValueService</a></li>
  <li><a href="#JavaTypeConstraintService">JavaTypeConstraintService</a></li>
  <li><a href="#ListSelectionService">ListSelectionService</a></li>
  <li><a href="#MasterConversionService">MasterConversionService</a></li>
  <li><a href="#PossibleTypesService">PossibleTypesService</a></li>
  <li><a href="#ProblemsTraversalService">ProblemsTraversalService</a></li>
  <li><a href="#VersionCompatibilityService">VersionCompatibilityService</a></li>
  <li><a href="#VersionCompatibilityTargetService">VersionCompatibilityTargetService</a></li>
</ul>

<a name="AdapterService"><h2>AdapterService</h2></a>

<p>The AdapterService provides means to extend the behavior of the adapt method in a given context.</p>

<p>For example, out of the box, Sapphire can adapt IModelElement to IProject assuming that the model is using
an IFile for the underlying resource store.  However, in some cases there may be no underlying IFile, so the
default logic will no be able to find IProject. To solve this problem, we can introduce an adapter service to 
provide a custom method for adopting IModelElement to IProject.</p>

<p style="margin-left: 20px;"><b>Example</b></p>

<pre class="source-code"><code>@Service( impl = NewProjectFileOpAdapterService.class )

<font color="#888888">public interface INewProjectFileOp extends IModelElement
{
    ...
}</font></code></pre>

<pre class="source-code"><code>public class NewProjectFileOpAdapterService extends AdapterService
{
    @Override
    public &lt;A&gt; A adapt( Class&lt;A&gt; adapterType )
    {
        if( IProject.class == adapterType )
        {
            INewProjectFileOp op = context( INewProjectFileOp.class );
            IProject project = op.getProject().resolve();

            if( project != null )
            {
                return adapterType.cast( project );
            }
        }

        return null;
    }
}</code></pre>

<a name="ContentProposalService"><h2>ContentProposalService</h2></a>

<p>The ContentProposalService provides a conduit for content assist in property editors. If a property
has this service, content assist will be automatically enabled in the property editor. The manner in which
content assist is presented is specific to the presentation, but usually involves a popup window with
proposals, activated by some combination of key strokes (such as CTRL+SPACE).</p>

<p>The framework provides an implementation of ContentProposalService for properties with @PossibleValues 
annotation or a custom PossibleValuesService, but this service can also be implemented directly by
adopters.</p> 

<p style="margin-left: 20px;"><img src="images/ContentProposalService.png"/></p>

<a name="ConversionService"><h2>ConversionService</h2></a>

<p>The ConversionService converts an object to the specified type. One common application is to convert
an input (such as a file) to a resource when instantiating the model.</p>

<table>
  <tr>
    <th>Sapphire.ConversionService.IFileToWorkspaceFileResourceStore</th>
  </tr>
  <tr>
    <td>Capable of converting an IFile to a WorkspaceFileResourceStore or a ByteArrayResourceStore.</td>
  </tr>
  <tr>
    <td style="border-width: 0px; height: 20px"></td>
  </tr>
  <tr>
    <th>Sapphire.ConversionService.ByteArrayResourceStoreToXmlResource</th>
  </tr>
  <tr>
    <td>Capable of converting a ByteArrayResourceStore to an XmlResource or a Resource. Conversion is only 
    performed if resource store corresponds   to a file with "xml" extension or if the context element type 
    has XML binding annotations.</td>
  </tr>
</table>

<p>A ConversionService can delegate to other conversion services to create a conversion chain. In fact,
a common conversion of IFile to XmlResource is a chain of two ConversionService implementations.</p>

<p style="margin-left: 20px;"><b>Example</b></p>

<p style="margin-left: 20px;">In the purchase order sample, a custom ConversionService is used because the 
default file extension for purchase order files is "po" rather than "xml" and PurchaseOrder element does not
have XML binding annotations. The combination of these two factors prevent the framework-provided ConversionService
implementations from engaging.</p>

<pre class="source-code"><code>@Service( impl = PurchaseOrderResourceConversionService.class )

<font color="#888888">public interface PurchaseOrder extends IModelElement
{
    ...
}</font></code></pre>

<pre class="source-code"><code>public class PurchaseOrderResourceConversionService extends ConversionService
{
    @Override
    public &lt;T> T convert( Object object, Class&lt;T> type )
    {
        if( type == XmlResource.class || type == Resource.class )
        {
            final ByteArrayResourceStore store = service( MasterConversionService.class ).convert( object, ByteArrayResourceStore.class );

            if( store != null )
            {
                return type.cast( new RootXmlResource( new XmlResourceStore( store ) ) );
            }
        }

        return null;
    }
}</code></pre>

<p style="margin-left: 20px;">Note the use of chaining as part of the presented ConversionService implementation. The 
input could be any number of things, but as long as another ConversionService implementation knows how to convert it 
to a ByteArrayResourceStore, this implementation will take the conversion the rest of the way to a Resource.</p> 

<a name="DependenciesAggregationService"><h2>DependenciesAggregationService</h2></a>

<p>The DependenciesAggregationService combines the data from all applicable dependencies services in order to produce 
a single set of dependencies. A dependency is a model paths that points to parts of the model that the property depends on. 
A property listens on all of its dependencies and triggers refresh when any of the dependencies change.</p>

<p>An implementation of this service is provided with Sapphire. This service is not intended to
be implemented by adopters. See <a href="#DependenciesService">DependenciesService</a> instead.</p>

<a name="DependenciesService"><h2>DependenciesService</h2></a>

<p>The DependenciesService produces the set of model paths that point to parts of the model that the property 
depends on. A property listens on all of its dependencies and triggers refresh when any of the dependencies change.</p>

<p>Although custom implementations are supported, in most cases the supplied implementation that is
configured via @DependsOn annotation should be sufficient.</p>

<p style="margin-left: 20px;"><b>Example</b></p>

<pre class="source-code"><code>@DependsOn( "Name" )

<font color="#888888">ValueProperty PROP_ID = new ValueProperty( TYPE, "Id" );

Value&lt;String> getId();
void setId( String value );</font></code></pre>

<p>Other annotations, such as @NoDuplicates can also inject implied dependencies (via their own DependenciesService
implementations). For instance, placing @NoDuplicates annotation on a Name property automatically
adds "#/Name" dependency.</p>

<p>If declarative approach is not sufficient, a custom DependenciesService implementation can be supplied.</p>

<p style="margin-left: 20px;"><b>Example</b></p>

<pre class="source-code"><code>public class CustomDependenciesService extends DependenciesService
{
    @Override
    protected DependenciesServiceData compute()
    {
        // Compute the list of dependencies.

        List&lt;ModelPath> dependencies = new ArrayList&lt;ModelPath>();

        ...

        return new DependenciesServiceData( dependencies );
    }
}</code></pre>

<pre class="source-code"><code>@Service( impl = CustomDependenciesService.class )

<font color="#888888">ValueProperty PROP_NAME = new ValueProperty( TYPE, "Name" );

Value&lt;String> getName();
void setName( String value );</font></code></pre>

<a name="DiagramLayoutPersistenceService"><h2>DiagramLayoutPersistenceService</h2></a>

<p>The DiagramLayoutPersistenceService is responsible for persisting layout of the diagram, such a location and
size of nodes, connection bend points, etc.</p>

<p>Unlike other services, DiagramLayoutPersistenceService is not defined by methods that must be
implemented, but rather by its expected behavior.</p>

<ol>
  <li>During service initialization, the implementation is expected to load layout information and transfer it to
    diagram parts using API such as DiagramNodePart.setNodeBounds().</li>
  <li>After initialization, the implementation is expected to listen for changes to diagram parts and persist
    layout information. Persistence can happen immediately or be deferred until the save event is received.</li>
  <li>If implementation defers layout persistence until save, it is expected to implement dirty() method and to
   issue DirtyStateEvent when this state changes.</li>
 </ol>

<p style="margin-left: 20px;"><b>Example</b></p>

<p style="margin-left: 20px;">The architecture sample provides a comprehensive example of a custom 
implementation that persists layout in the same file as data.</p>

<a name="DragAndDropService"><h2>DragAndDropService</h2></a>

<p>The DragAndDropService provides means to implement drag-n-drop behavior in a diagram editor.</p>

<p style="margin-left: 20px;"><b>Example</b></p>

<pre class="source-code"><code>public class MapDragAndDropService extends DragAndDropService 
{
    @Override
    public boolean droppable( DropContext context ) 
    {
        return context.object() instanceof IFile;
    }

    @Override
    public void drop( DropContext context ) 
    {
        IFile file = (IFile) context.object();
        List<String> locations = new ArrayList<String>();

        InputStream in = null;

        try
        {
            in = file.getContents();
            final BufferedReader br = new BufferedReader( new InputStreamReader( in ) );

            for( String line = br.readLine(); line != null; line = br.readLine() )
            {
                if( line != null )
                {
                    line = line.trim();

                    if( line.length() > 0 )
                    {
                        locations.add( line );
                    }
                }
            }
        }
        catch( CoreException e )
        {
            LoggingService.log( e );
        }
        catch( IOException e )
        {
            LoggingService.log( e );
        }
        finally
        {
            if( in != null )
            {
                try
                {
                    in.close();
                }
                catch( IOException e ) {}
            }
        }

        if( ! locations.isEmpty() )
        {
            SapphireDiagramEditorPagePart diagram = context( SapphireDiagramEditorPagePart.class );
            Map map = context( Map.class );

            Point initialDropPosition = context.position();

            int x = initialDropPosition.getX();
            int y = initialDropPosition.getY();

            for( String locationName : locations )
            {
                if( ! map.hasLocation( locationName ) )
                {
                    Location location = map.getLocations().insert();
                    location.setName( locationName );

                    DiagramNodePart locationNodePart = diagram.getDiagramNodePart(location);
                    locationNodePart.setNodeBounds( x, y );

                    x += 50;
                    y += 50;
                }
            }
        }
    }
}</code></pre>

<p style="margin-left: 20px;">The DragAndDropService is typically registered as part of diagram page
definition in the sdef file.</p>

<pre class="source-code"><code><font color="#888888">&lt;diagram-page></font>
    &lt;service>
        &lt;implementation>MapDropService&lt;/implementation>
    &lt;/service>
<font color="#888888">&lt;/diagram-page></font></code></pre>

<a name="EqualityService"><h2>EqualityService</h2></a>

<p>The EqualityService provides means to implement equals() and hashCode() methods when the context object doesn't support
implementing these methods directly. One such context is model elements, where the framework does not rely on a particular
implementation of these methods, but having these methods behave in a way consistent with semantics of the data being modeled
can be useful for other purposes.</p>

<p style="margin-left: 20px;"><b>Example</b></p>

<pre class="source-code"><code>public class ContactEqualityService extends EqualityService
{
    @Override
    public boolean doEquals( Object obj )
    {
        Contact c1 = context( Contact.class );
        Contact c2 = (Contact) obj;

        return equal( c1.getLastName().getText(), c2.getLastName().getText() ) &&
               equal( c1.getFirstName().getText(), c2.getFirstName().getText() );
    }

    @Override
    public int doHashCode()
    {
        Contact c = context( Contact.class );
        String lastName = c.getLastName().getText();
        String firstName = c.getFirstName().getText();

        return ( lastName == null ? 1 : lastName.hashCode() ) ^ ( firstName == null ? 1 : firstName.hashCode() );
    }

    private static boolean equal( Object obj1, Object obj2 )
    {
        if( obj1 == obj2 )
        {
            return true;
        }
        else if( obj1 != null && obj2 != null )
        {
            return obj1.equals( obj2 );
        }

        return false;
    }
}</code></pre>

<pre class="source-code"><code><font color="#888888">@Services( {</font> @Service( impl = ContactEqualityService.class )<font color="#888888">, ... } )

public interface Contact extends IModelElement
{
    ModelElementType TYPE = new ModelElementType( Contact.class );

    ...
}</font></code></pre>

<a name="FactsAggregationService"><h2>FactsAggregationService</h2></a>

<p>The FactsAggregationService combines the data from all applicable facts services in order to produce 
a single list of facts. A fact is a short statement describing property semantics.</p>

<p>An implementation of this service is provided with Sapphire. This service is not intended to
be implemented by adopters. See <a href="#FactsService">FactsService</a> to contribute facts.</p>

<a name="FactsService"><h2>FactsService</h2></a>

<p>When a property is described to a user in documentation one does it with a series of short statements that
define its semantics, such as "must be specified" or "maximum value is 100". When a property is
described to Sapphire one does it with a series of annotations, such as @Required or
@NumericRange. This duplicate specification is a maintenance problem.</p>

<p>A FactsService provides a means to dynamically derive statements about property's semantics
based on property's metadata. The derived facts can then be presented to the user as part of documentation,
property editor information popup and in other relevant places.</p>

<p>A single facts service can produce multiple facts and multiple facts services can be active 
concurrently for a given property. See <a href="#FactsAggregationService">FactsAggregationService</a> for 
an easier way to consume all facts.</p>

<p>Sapphire includes a number of FactsService implementations.</p> 

##facts-servicess##

<p style="margin-left: 20px;"><b>Example</b></p>

<p style="margin-left: 20px;">This screen capture shows user experience with some of the provided FactsService 
implementation. See if you can match facts in the screen capture to service implementations above.</p>

<p style="margin-left: 20px;"><img src="images/FactsService.png"/></p>

<p>Adopters can provide custom FactService implementations either globally using Sapphire extension system or 
at the property level using @Service annotation.</p>

<p style="margin-left: 20px;"><b>Example</b></p>

<p style="margin-left: 20px;">A simple global FactsService implementation that is triggered by a hypothetical 
@Since property annotation.</p>

<pre class="source-code"><code>public class SinceVersionFactsService extends FactsService
{
    @Override
    protected void facts( List facts )
    {
        Since since = property().getAnnotation( Since.class );
        facts.add( "Since version " + since.version() + "." );
    }

    public static class Factory extends ServiceFactory
    {
        @Override
        public boolean applicable( ServiceContext context,
                                   Class&lt;? extends Service> service )
        {
            return context.find( ModelProperty.class ).hasAnnotation( Since.class );
        }

        @Override
        public Service create( ServiceContext context,
                               Class&lt;? extends Service> service )
        {
            return new SinceVersionFactsService();
        }
    }
}</code></pre>

<p style="margin-left: 20px;">The service implementation is registered in META-INF/sapphire-extension.xml file.</p>

<pre class="source-code"><code><font color="#888888">&lt;extension xmlns="http://www.eclipse.org/sapphire/xmlns/extension"></font>
    &lt;service>
        &lt;id>Example.SinceVersionFactsService&lt;/id>
        &lt;type>org.eclipse.sapphire.services.FactsService&lt;/type>
        &lt;context>Sapphire.Property.Instance&lt;/context>
        &lt;factory>example.SinceVersionFactsService$Factory&lt;/factory>
    &lt;/service>
<font color="#888888">&lt;/extension></font></code></pre>

<p>Facts can also be statically specified for a given property by using @Fact annotation. Use @Facts
annotation to specify multiple facts. The facts contained in these annotations are surfaced by an
included FactsService implementation (id:Sapphire.FactsService.Static).</p>

<p style="margin-left: 20px;"><b>Example</b></p>

<pre class="source-code"><code><font color="#888888">// *** ExampleOne ***</font>

@Fact( statement = "Important fact.")

<font color="#888888">ValueProperty PROP_EXAMPLE_ONE = new ValueProperty( TYPE, "ExampleOne" );

Value&lt;String> getExampleOne();
void setExampleOne( String value );

// *** ExampleMultiple ***</font>

@Facts( { @Fact( statement = "First important fact." ), @Fact( statement = "Second important fact." ) } )

<font color="#888888">ValueProperty PROP_EXAMPLE_MULTIPLE = new ValueProperty( TYPE, "ExampleMultiple" );

Value&lt;String> getExampleMultiple();
void setExampleMultiple( String value );</font></code></pre>

<a name="FileExtensionsService"><h2>FileExtensionsService</h2></a>

<p>The FileExtensionsService produces the list of file extensions that are allowed for a path value 
property.</p>

<p>Although custom implementations are supported, in most cases the supplied implementation that
is configured via @FileExtensions annotation should be sufficient. In many cases, specifying
file extensions is as simple as listing them with a comma in between.</p> 

<p style="margin-left: 20px;"><b>Example</b></p>

<pre class="source-code"><code><font color="#888888">@Type( base = Path.class )
@AbsolutePath
@MustExist
@ValidFileSystemResourceType( FileSystemResourceType.FILE )</font>
@FileExtensions( expr = "jar,zip" )

<font color="#888888">ValueProperty PROP_FILE_PATH = new ValueProperty( TYPE, "FilePath" );

Value&lt;Path> getFilePath();
void setFilePath( String value );
void setFilePath( Path value );</font></code></pre>

<p>File extensions can also be specified via an expression that takes into
account values of other properties.</p>

<p style="margin-left: 20px;"><b>Examples</b></p>

<pre class="source-code"><code>@FileExtensions( expr = "${ Extension }" )</code></pre>

<pre class="source-code"><code>@FileExtensions( expr = "${ LossyFormat ? "jpeg,jpg" : "png,gif" }" )</code></pre>

<p>If declarative approach is not sufficient, a custom FileExtensionsService implementation can
be supplied.</p>

<p style="margin-left: 20px;"><b>Example</b></p>

<pre class="source-code"><code>public class CustomFileExtensionsService extends FileExtensionsService
{
    @Override
    protected void initFileExtensionsService()
    {
        // Optionally register listeners to invoke refresh method when the list of extensions
        // may need to be updated.
    }

    @Override
    protected FileExtensionsServiceData compute()
    {
        // Compute the list of extensions.

        List&lt;String> extensions = new ArrayList&lt;String>();

        ...

        return new FileExtensionsServiceData( extensions );
    }

    @Override
    public void dispose()
    {
        super.dispose();

        // Remove any listeners that were added during initialization.
    }
}</code></pre>

<pre class="source-code"><code><font color="#888888">@Type( base = Path.class )
@AbsolutePath
@MustExist
@ValidFileSystemResourceType( FileSystemResourceType.FILE )</font>
@Service( impl = CustomFileExtensionsService.class )

<font color="#888888">ValueProperty PROP_FILE_PATH = new ValueProperty( TYPE, "FilePath" );

Value&lt;Path> getFilePath();
void setFilePath( String value );
void setFilePath( Path value );</font></code></pre>

<a name="InitialValueService"><h2>InitialValueService</h2></a>

<p>The InitialValueService produces a value to assign to a property when the containing model element is
created.</p>

<p>The concept of an initial value is different from a default value. The initial value is explicitly
assigned to the property during containing model element's creation. This includes writing to the backing resource
(such as an XML document). In comparison, the default value is used when null is read for a property from the 
backing resource. As such, the default value is only visible to model consumers (such as the user interface), 
while the initial value is persisted.</p> 

<p>Whether you use an initial value or a default value is frequently dictated by the requirements of the 
backing resource. As an example, let's consider an XML document that stores phone numbers. In this XML document, 
the phone number element has a type child element which contains a value like home, mobile, work, etc.
Let's further say that semantically, we wish to use mobile phone number type unless specified differently.
Now, if the XML schema dictates that the phone number type element is required, we would need to specify 
"mobile" as the initial value. If the phone number type element is optional, it would be better to specify
"mobile" as the default value.</p>

<p>In many situations, the initial value is static and should be configured using @InitialValue annotation.</p>

<p style="margin-left: 20px;"><b>Example</b></p>

<pre class="source-code"><code><font color="#888888">@Required
@PossibleValues( values = { "home", "mobile", "work", "other" }, invalidValueSeverity = Status.Severity.OK )</font>
@InitialValue( text = "mobile" )

<font color="#888888">ValueProperty PROP_TYPE = new ValueProperty( TYPE, "Type" );

Value&lt;String> getType();
void setType( String type );</font></code></pre>

<p>When the initial value varies due to runtime conditions, a custom implementation of InitialValueService can 
be provided.</p>

<p style="margin-left: 20px;"><b>Example</b></p>

<pre class="source-code"><code>public class PhoneTypeInitialValueService extends InitialValueService
{
    @Override
    protected void initInitialValueService()
    {
        // Register listeners to invoke refresh() method when the initial value
        // may have changed.
    }

    @Override
    protected InitialValueServiceData compute()
    {
        // Compute the initial value.

        String value;

        ...

        return new InitialValueServiceData( value );
    }

    @Override
    public void dispose()
    {
        super.dispose();

        // Remove any listeners that were added during initialization.
    }
}</code></pre>

<pre class="source-code"><code><font color="#888888">@Required
@PossibleValues( values = { "home", "mobile", "work", "other" }, invalidValueSeverity = Status.Severity.OK )</font>
@Service( impl = PhoneTypeInitialValueService.class )

<font color="#888888">ValueProperty PROP_TYPE = new ValueProperty( TYPE, "Type" );

Value&lt;String> getType();
void setType( String type );</font></code></pre>

<a name="JavaTypeConstraintService"><h2>JavaTypeConstraintService</h2></a>

<p>The JavaTypeConstraintService describes constraints on the Java type that a property can reference, such as the kind of
type (class, interface, etc.) and the types that the type must extend or implement. The information provided by this
service is used for validation, content assist and other needs.  

<p>In majority of situations, the Java type constraint is static and should be configured using @JavaTypeConstraint 
annotation. The framework provides an implementation of JavaTypeConstraintService that works with this annotation.</p>

<p style="margin-left: 20px;"><b>Example</b></p>

<pre class="source-code"><code><font color="#888888">@Type( base = JavaTypeName.class )
@Reference( target = JavaType.class )</font>
@JavaTypeConstraint( kind = JavaTypeKind.CLASS, type = "javax.servlet.Filter" )

<font color="#888888">ValueProperty PROP_SERVLET_FILTER_IMPL = new ValueProperty( TYPE, "ServletFilterImpl" );

ReferenceValue&lt;JavaTypeName,JavaType> getServletFilterImpl();
void setServletFilterImpl( JavaTypeName value );
void setServletFilterImpl( String value );</font></code></pre>

<p>When the Java type constraint varies due to runtime conditions, a custom implementation of JavaTypeConstraintService
 can be provided.</p>

<p style="margin-left: 20px;"><b>Example</b></p>

<pre class="source-code"><code>public class CustomJavaTypeConstraintService extends JavaTypeConstraintService
{
    @Override
    protected void initJavaTypeConstraintService()
    {
        // Register listeners to invoke refresh() method when Java type constraint
        // may have changed.
    }

    @Override
    protected JavaTypeConstraintServiceData compute()
    {
        // Compute Java type constraint.

        List&lt;JavaTypeKind> kinds = new ArrayList&lt;JavaTypeKind>();
        List&lt;String> types = new ArrayList&lt;String>();
        JavaTypeConstraintBehavior behavior;

        ...

        return new JavaTypeConstraintServiceData( kinds, types, behavior );
    }

    @Override
    public void dispose()
    {
        super.dispose();

        // Remove any listeners that were added during initialization.
    }
}</code></pre>

<pre class="source-code"><code><font color="#888888">@Type( base = JavaTypeName.class )
@Reference( target = JavaType.class )</font>
@Service( impl = CustomJavaTypeConstrainService.class )

<font color="#888888">ValueProperty PROP_SERVLET_FILTER_IMPL = new ValueProperty( TYPE, "ServletFilterImpl" );

ReferenceValue&lt;JavaTypeName,JavaType> getServletFilterImpl();
void setServletFilterImpl( JavaTypeName value );
void setServletFilterImpl( String value );</font></code></pre>

<a name="ListSelectionService"><h2>ListSelectionService</h2></a>

<p>The ListSelectionService functions as a conduit between the presentation layer and anything that may want to see or 
change the selection. The presentation layer pushes selection changes made by the user to ListSelectionService and at
the same time listens for changes to selection coming from ListSelectionService.</p>

<p>An implementation of this service is provided with Sapphire. This service is not intended to be implemented by adopters.</p>

<p style="margin-left: 20px;"><b>Example</b></p>

<p style="margin-left: 20px;">In this example, an action handler attaches a listener to the ListSelectionService to 
refresh action handler's enablement state when selection changes.</p>

<pre class="source-code"><code>
<font color="#888888">public class ExampleActionHandler extends SapphireActionHandler
{
    @Override
    public void init( SapphireAction action, ActionHandlerDef def )
    {
        super.init( action, def );</font>

        final ListSelectionService selectionService = action.getPart().service( ListSelectionService.class );

        final Listener selectionListener = new Listener()
        {
            @Override
            public void handle( Event event )
            {
                refreshEnablementState();
            }
        };

        selectionService.attach( selectionListener );

        attach
        (
            new Listener()
            {
                @Override
                public void handle( Event event )
                {
                    if( event instanceof DisposeEvent )
                    {
                        selectionService.detach( selectionListener );
                    }
                }
            }
        );
    <font color="#888888">}
}</font></code></pre>

<a name="MasterConversionService"><h2>MasterConversionService</h2></a>

<p>The MasterConversionService converts an object to the specified type by delegating to available ConversionService 
implementations. If object is null or is already of desired type, the object is returned unchanged.</p> 

<p>An implementation of this service is provided with Sapphire. This service is not intended to
be implemented by adopters. See <a href="#ConversionService">ConversionService</a> instead.</p>

<p style="margin-left: 20px;"><b>Example</b></p>

<p style="margin-left: 20px;">In this example, an IFile is converted to a Resource as part of instantiating the model.
Note how this code is not aware of the details of the conversion or what type of a resource is created.</p>

 <pre class="source-code"><code><font color="#888888">IFile file = project.getFile( "contacts.xml" )</font>
Resource resource = ContactRepository.TYPE.service( MasterConversionService.class ).convert( file, Resource.class );
<font color="#888888">ContactRepository model = ContactRepository.TYPE.instantiate( resource );</font></code></pre>

<a name="PossibleTypesService"><h2>PossibleTypesService</h2></a>

<p>The PossibleTypesService enumerates the possible child element types for a list or an element property. Each 
returned type is required to derive from the property's base type.</p>

<p>In majority of situations, the set of possible types is static and should be configured using @Type annotation. 
The framework provides an implementation of PossibleTypesService that works with this annotation.</p>

<p style="margin-left: 20px;"><b>Example</b></p>

<pre class="source-code"><code><font color="#888888">@Type( base = Shape.class,</font> possible = { Circle.class, Triangle.class, Rectangle.class } <font color="#888888">)

ListProperty PROP_SHAPES = new ListProperty( TYPE, "Shapes" );

ModelElementList&lt;Shape> getShapes();</font></code></pre>

<p>When the set of possible types varies due to model extensibility or runtime conditions, a custom implementation
of PossibleTypesService can be provided.</p>

<p style="margin-left: 20px;"><b>Example</b></p>

<pre class="source-code"><code>public class ShapesPossibleTypesService extends PossibleTypesService
{
    @Override
    protected void initPossibleTypesService()
    {
        // Register listeners to invoke refresh() method when the list of possible types
        // may have changed.
    }

    @Override
    protected PossibleTypesServiceData compute()
    {
        // Compute the list of possible types.

        List&lt;ModelElementType> types = new ArrayList&lt;ModelElementType>();

        ...

        return new PossibleTypesServiceData( types );
    }

    @Override
    public void dispose()
    {
        super.dispose();

        // Remove any listeners that were added during initialization.
    }
}</code></pre>

<pre class="source-code"><code><font color="#888888">@Type( base = Shape.class )</font>
@Service( impl = ShapesPossibleTypesService.class )

<code><font color="#888888">ListProperty PROP_SHAPES = new ListProperty( TYPE, "Shapes" );

ModelElementList&lt;Shape> getShapes();</font></code></pre>

<p>If the set of possible types is not specified via @Type annotation or via a custom PossibleTypesService
implementation, the set of possible types is defined to be a singleton set composed of the property's base
type.</p>

<a name="ProblemsTraversalService"><h2>ProblemsTraversalService</h2></a>

<p>ProblemsTraversalService produces a problem-annotated traversal order through the content outline, which can 
be used to find the next error or warning from any location in the content outline.</p>

<p>An implementation of this service is provided with Sapphire. This service is not intended to be implemented 
by adopters.</p>

<pre class="source-code"><code>ProblemsTraversalService extends DataService&lt;ProblemsTraversalServiceData>
{
    MasterDetailsContentNode findNextProblem( MasterDetailsContentNode reference, Status.Severity severity )
    MasterDetailsContentNode findNextError( MasterDetailsContentNode reference )
    MasterDetailsContentNode findNextWarning( MasterDetailsContentNode reference )
}</code></pre>

<p style="margin-left: 20px;"><b>Example</b></p>

<pre class="source-code"><code>public class ShowNextErrorActionHandler extends SapphireActionHandler
{
    private ProblemsTraversalService service;

    @Override
    public void init( final SapphireAction action,
                      final ActionHandlerDef def )
    {
        super.init( action, def );

        final MasterDetailsContentNode node = (MasterDetailsContentNode) getPart();
        final MasterDetailsEditorPagePart page = node.nearest( MasterDetailsEditorPagePart.class );

        this.service = page.service( ProblemsTraversalService.class );

        final Listener listener = new Listener()
        {
            @Override
            public void handle( final Event event )
            {
                refreshVisibility();
            }
        };

        this.service.attach( listener );

        attach
        (
            new FilteredListener&lt;DisposeEvent>()
            {
                @Override
                protected void handleTypedEvent( final DisposeEvent event )
                {
                    ShowNextErrorActionHandler.this.service.detach( listener );
                }
            }
        );

        refreshVisibility();
    }

    private void refreshVisibility()
    {
        final MasterDetailsContentNode node = (MasterDetailsContentNode) getPart();
        final MasterDetailsContentNode nextProblemNode = this.service.findNextError( node );

        setVisible( nextProblemNode != null );
    }

    private PropertyEditorPart findFirstError( final List&lt;SectionPart> sections )
    {
        for( SectionPart section : sections )
        {
            final PropertyEditorPart res = findFirstError( section );

            if( res != null )
            {
                return res;
            }
        }

        return null;
    }

    private PropertyEditorPart findFirstError( final SapphirePart part )
    {
        if( part != null )
        {
            if( part instanceof PropertyEditorPart )
            {
                if( part.validation().severity() == Status.Severity.ERROR )
                {
                    return (PropertyEditorPart) part;
                }
            }
            else if( part instanceof FormPart )
            {
                for( SapphirePart p : ( (FormPart) part ).getChildParts() )
                {
                    final PropertyEditorPart result = findFirstError( p );

                    if( result != null )
                    {
                        return result;
                    }
                }
            }
            else if( part instanceof PageBookPart )
            {
                return findFirstError( ( (PageBookPart) part ).getCurrentPage() );
            }
        }

        return null;
    }

    @Override
    protected Object run( final SapphireRenderingContext context )
    {
        final MasterDetailsContentNode node = (MasterDetailsContentNode) getPart();
        final MasterDetailsContentNode nextProblemNode = this.service.findNextError( node );

        if( nextProblemNode != null )
        {
            nextProblemNode.select();

            final PropertyEditorPart firstProblemPropertyEditor = findFirstError( nextProblemNode.getSections() );

            if( firstProblemPropertyEditor != null )
            {
                firstProblemPropertyEditor.setFocus();
            }
        }

        return null;
    }
}</code></pre>

<a name="VersionCompatibilityService"><h2>VersionCompatibilityService</h2></a>

<p>VersionCompatibilityService determines whether a property is compatible with the version compatibility target.
This in turn controls property enablement, validation and visibility.</p>

<p>In most situations, version compatibility can be expressed using an @Since or an @VersionCompatibility annotation.
Both of these annotations support <a href="../el/index.html">the expression language</a>.</p>

<p style="margin-left: 20px;"><b>Example</b></p>

<pre class="source-code"><code><font color="#888888">@Type( base = Date.class )</font>
@Since( "1.5" )

<font color="#888888">ValueProperty PROP_INITIAL_QUOTE_DATE = new ValueProperty( TYPE, "InitialQuoteDate" );

Value&lt;Date> getInitialQuoteDate();
void setInitialQuoteDate( String value );
void setInitialQuoteDate( Date value );</font></code></pre>

<p>When more control is necessary, a custom implementation of VersionCompatibilityService can be provided. A
typical implementation will utilize VersionCompatibilityTargetService to determine the current version.</p>

<p style="margin-left: 20px;"><b>Example</b></p>

<pre class="source-code"><code><font color="#888888">@Type( base = Date.class )</font>
@Service( impl = ExampleVersionCompatibilityService.class )

<font color="#888888">ValueProperty PROP_INITIAL_QUOTE_DATE = new ValueProperty( TYPE, "InitialQuoteDate" );

Value&lt;Date> getInitialQuoteDate();
void setInitialQuoteDate( String value );
void setInitialQuoteDate( Date value );</font></code></pre>

<pre class="source-code"><code>public class ExampleVersionCompatibilityService extends VersionCompatibilityService
{
    private VersionCompatibilityTargetService versionCompatibilityTargetService;
    private Listener versionCompatibilityTargetServiceListener;

    protected void initVersionCompatibilityService()
    {
        final IModelElement element = context( IModelElement.class );
        final ModelProperty property = context( ModelProperty.class );

        this.versionCompatibilityTargetService = VersionCompatibilityTargetService.find( element, property );

        this.versionCompatibilityTargetServiceListener = new Listener()
        {
            @Override
            public void handle( final Event event )
            {
                refresh();
            }
        };

        this.versionCompatibilityTargetService.attach( this.versionCompatibilityTargetServiceListener );
    }

    @Override
    protected Data compute()
    {
        final Version version = this.versionCompatibilityTargetService.version();
        final String versioned = this.versionCompatibilityTargetService.versioned();

        final boolean compatible = ...

        return new Data( compatible, version, versioned );
    }

    @Override
    public void dispose()
    {
        super.dispose();

        if( this.versionCompatibilityTargetService != null )
        {
            this.versionCompatibilityTargetService.detach( this.versionCompatibilityTargetServiceListener );
        }
    }
}</code></pre>

<a name="VersionCompatibilityTargetService"><h2>VersionCompatibilityTargetService</h2></a>

<p>VersionCompatibilityTargetService produces the version compatibility target to be referenced 
by VersionCompatibilityService.</p>

<p>When looking for the version compatibility target, the framework will first check the property, then the containing
element, then the parent property and the parent element, etc. The search continues until version compatibility target 
is found or the model root is reached.</p>

<p>In most situations, version compatibility target can be expressed using an @VersionCompatibilityTarget annotation,
which supports <a href="../el/index.html">the expression language</a>.</p>

<pre class="source-code"><code>@VersionCompatibilityTarget( version = "${ Version }", versioned = "Purchase Order" )

<font color="#888888">public interface PurchaseOrder extends IModelElement
{
    ModelElementType TYPE = new ModelElementType( PurchaseOrder.class );</font>

    // *** Version ***

    @Type( base = Version.class )
    @DefaultValue( text = "2.0" )

    ValueProperty PROP_VERSION = new ValueProperty( TYPE, "Version" );

    Value&lt;Version> getVersion();
    void setVersion( String value );
    void setVersion( Version value );

    <font color="#888888">...
}</font></code></pre>

<p>When more control is necessary, a custom implementation of VersionCompatibilityTargetService can be provided.</p>

<pre class="source-code"><code>@Service( impl = ExampleVersionCompatibilityTargetService.class )

<font color="#888888">public interface PurchaseOrder extends IModelElement
{
    ...
}</font></code></pre>

<pre class="source-code"><code>public class ExampleVersionCompatibilityTargetService extends VersionCompatibilityTargetService
{
    @Override
    protected void initContextVersionService()
    {
        // Listen on the source of the version and call refresh() when necessary.
    }

    @Override
    protected Data compute()
    {
        Version version = ...
        String versioned = ...

        return new Data( version, versioned );
    }

    @Override
    public void dispose()
    {
        super.dispose();

        // Detach any listeners attached in the initContextVersionService() method.
    }
}</code></pre>

<div class="copyright">Copyright (c) 2013 Oracle and Liferay<br/>
Content made available under the terms of <a href="http://www.eclipse.org/legal/epl-v10.html">Eclipse Public License</a>.</div>

</body>

</html>