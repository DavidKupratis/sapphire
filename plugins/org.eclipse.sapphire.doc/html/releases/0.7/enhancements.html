<!-- 
 ******************************************************************************
 * Copyright (c) 2013 Oracle
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/epl-v10.html
 *
 * Contributors:
 *    Konstantin Komissarchik - initial implementation and ongoing maintenance
 ******************************************************************************
-->

<html>

<head>
  <title>Enhancements in Sapphire 0.7</title>
  <link rel="StyleSheet" href="../../style.css" TYPE="text/css"/>
</head>

<body>

<h1>Enhancements in 0.7</h1>

<ol>
  <li><a href="#Key">Key Enhancements</a></li>
  <ol type="A">
    <li><a href="#Key-OnDemandElementCompilation">On-Demand Element Compilation</a></li>
    <li><a href="#Key-ConsolidatedConversions">Consolidated Conversions</a></li>
    <li><a href="#Key-ExtensiblePersistentState">Extensible Persistent State</a></li>
  </ol>
  <li><a href="#Core">Core</a></li>
  <ol type="A">
    <li><a href="#Core-ModelElement">ModelElement</a></li>
    <li><a href="#Core-ModelElementHandle">ModelElementHandle</a></li>
    <li><a href="#Core-RequiredConstraintService">RequiredConstraintService</a></li>
    <li><a href="#Core-RootServiceContext">Root Service Context</a></li>
    <li><a href="#Core-ServiceRegistrationWithoutFactory">Service Registration Without a Factory</a></li>
    <li><a href="#Core-NewConversions">New Conversions</a></li>
  </ol>
  <li><a href="#ExpressionLanguage">Expression Language</a></li>
  <ol type="A">
    <li><a href="#ExpressionLanguage-UseForValidation">Use for Validation</a></li>
    <li><a href="#ExpressionLanguage-UseInRequired">Use in @Required</a></li>
    <li><a href="#ExpressionLanguage-EnabledFunction">Enabled Function</a></li>
    <li><a href="#ExpressionLanguage-OperandScopedFunctions">Operand-Scoped Function</a></li>
    <li><a href="#ExpressionLanguage-StateFunction">State Function</a></li>
  </ol>
  <li><a href="#Forms">Forms</a></li>
  <ol type="A">
    <li><a href="#Forms-SectionReference">Section Reference</a></li>
    <li><a href="#Forms-ColorBrowsing">Color Browsing</a></li>
  </ol>
  <li><a href="#Miscellaneous">Miscellaneous</a></li>
  <ol type="A">
    <li><a href="#Miscellaneous-JavaIdentifier">JavaIdentifier</a></li>
  </ol>
</ol>

<h2><a name="Key"><a name="Key-OnDemandElementCompilation">On-Demand Element Compilation</a></a></h2>

<p>In past releases, Sapphire used a Java annotation processor linked to @GenerateImpl annotation to
produce implementation classes for model element interfaces at build time. This system has been
replaced by on-demand compilation straight to Java bytecode. When application code instantiates an
element for the first time, Sapphire will automatically compile it and use the compiled result for
the duration of the JVM instance.</p>

<p>The on-demand approach makes it easier to get started with Sapphire as it does not require build
customization to compile implementation classes.</p>


<h2><a name="Key-ConsolidatedConversions">Consolidated Conversions</a></h2>

<p>ValueSerializationService, AdapterService and EL's TypeCast API have been consolidated with
ConversionService. The result is a single API for implementing conversions. Many of the basic
conversions are now available in the root service context, opening the door for novel uses.</p>

<p style="margin-left: 20px;"><b>Example</b></p>

<pre class="source-code"><code>Integer number = Sapphire.service( MasterConversionService.class ).convert( "123", Integer.class );</code></pre>

<p style="margin-left: 20px;"><b>Example</b></p>

<p style="margin-left: 20px;">In this example, the generics are used in conjunction with Sapphire's library of conversions
to implement the pattern where the type of the default value controls the return type. This pattern
is typically implemented as a less flexible series of overloaded methods for various types.</p>  

<pre class="source-code"><code>public class AttributesContainer
{
    private final Map&lt;String,String> attributes = new HashMap&lt;String,String>();
    
    public &lt;T> T getAttribute( final String name, final T def )
    {
        if( name == null )
        {
            throw new IllegalArgumentException();
        }
        
        Object value = this.attributes.get( name );
        
        if( value != null && def != null && def != String.class )
        {
            value = Sapphire.service( MasterConversionService.class ).convert( value, def.getClass() );
        }
        
        if( value == null )
        {
            value = def;
        }
        
        return (T) value;
    }
    
    public String getAttribute( final String name )
    {
        return (String) getAttribute( name, null );
    }

    public void setAttribute( final String name, final Object value )
    {
        if( name == null )
        {
            throw new IllegalArgumentException();
        }
        
        if( value == null )
        {
            this.attributes.remove( name );
        }
        else
        {
            final String string = Sapphire.service( MasterConversionService.class ).convert( value, String.class );
            this.attributes.put( name, string );
        }
    }
}</code></pre>


<h2><a name="Key-ExtensiblePersistentState">Extensible Persistent State</a></h2>

<p>Editor pages are able to persist user interface state between sessions independent of the data 
that is being edited. What state is persisted is dependent on editor page type. Two common examples of
persistent state are sizing of resizable elements and selection. The persistent state is now extensible,
allowing adopters to persist custom data.</p>

<p>The recommended approach is to extend the page's persistent state element type to add custom properties.
The custom element type for persistent state is specified in sdef.</p> 

<p style="margin-left: 20px;"><b>Example</b></p>

<p style="margin-left: 20px;">In the catalog sample, a toggle action controls whether the manufacturer name is shown
in the catalog item label. The state of this toggle is persisted by extending the state of the editor page. The
persistent state is also used for communication between the toggle and the item label.</p>

<pre class="source-code"><code>public interface CatalogEditorPageState extends MasterDetailsEditorPageState
{
    ModelElementType TYPE = new ModelElementType( CatalogEditorPageState.class );

    // *** ShowManufacturer ***

    @Type( base = Boolean.class )
    @DefaultValue( text = "false" )

    ValueProperty PROP_SHOW_MANUFACTURER = new ValueProperty( TYPE, "ShowManufacturer" );

    Value&lt;Boolean> getShowManufacturer();
    void setShowManufacturer( String value );
    void setShowManufacturer( Boolean value );
}</code></pre>

<p style="margin-left: 20px;">The custom state element type is attached to the editor page in sdef.</p>

<pre class="source-code"><code><font color="#888888">&lt;editor-page></font>
    &lt;persistent-state-element-type>org.eclipse.sapphire.samples.catalog.CatalogEditorPageState&lt;/persistent-state-element-type>
<font color="#888888">&lt;/editor-page></font></code></pre>

<p style="margin-left: 20px;">The toggle action handler only interacts with the editor page state.</p>

<pre class="source-code"><code>public final class ShowManufacturerActionHandler extends SapphireActionHandler 
{
    private CatalogEditorPageState state;

    @Override
    public void init( final SapphireAction action, final ActionHandlerDef def )
    {
        super.init( action, def );

        this.state = (CatalogEditorPageState) getPart().nearest( SapphireEditorPagePart.class ).state();

        final Listener listener = new FilteredListener&lt;PropertyContentEvent>()
        {
            @Override
            protected void handleTypedEvent( final PropertyContentEvent event )
            {
                setChecked( ShowManufacturerActionHandler.this.state.getShowManufacturer().getContent() );
            }
        };

        this.state.attach( listener, CatalogEditorPageState.PROP_SHOW_MANUFACTURER );

        setChecked( this.state.getShowManufacturer().getContent() );

        attach
        (
            new FilteredListener&lt;DisposeEvent>()
            {
                @Override
                protected void handleTypedEvent( final DisposeEvent event )
                {
                    ShowManufacturerActionHandler.this.state.detach( listener, CatalogEditorPageState.PROP_SHOW_MANUFACTURER );
                }
            }
        );
    }

    @Override
    protected Object run( final SapphireRenderingContext context )
    {
        this.state.setShowManufacturer( ! this.state.getShowManufacturer().getContent() );

        return null;
    }
}</code></pre>

<p style="margin-left: 20px;">The toggle action and its handler are defined in sdef.</p>

<pre class="source-code"><code><font color="#888888">&lt;editor-page></font>
    &lt;action>
        &lt;id>Sample.ShowManufacturer&lt;/id>
        &lt;label>Show Manufacturer&lt;/label>
        &lt;image>ShowManufacturer.png&lt;/image>
        &lt;type>TOGGLE&lt;/type>
        &lt;context>Sapphire.EditorPage&lt;/context>
        &lt;location>before:Sapphire.Outline.Hide&lt;/location>
    &lt;/action>
    &lt;action-handler>
        &lt;action>Sample.ShowManufacturer&lt;/action>
        &lt;id>Sample.ShowManufacturer&lt;/id>
        &lt;impl>ShowManufacturerActionHandler&lt;/impl>
    &lt;/action-handler>
<font color="#888888">&lt;/editor-page></font></code></pre>

<p style="margin-left: 20px;">Finally, the content outline node label for a catalog item is defined using an expression that reads
the editor page state to determine whether to include the manufacturer in the label. The label automatically updates when any
of the properties utilized in the expression are changed.</p>

<pre class="source-code"><code><font color="#888888">&lt;node-factory>
    &lt;property>Items&lt;/property>
    &lt;case>
        &lt;label></font>${ Name == null ? &quot;&lt;item&gt;&quot; : ( State().ShowManufacturer &amp;&amp; Manufacturer != null ? Concat( Manufacturer, &quot; &quot;, Name ) : Name ) }<font color="#888888">&lt;/label>
    &lt;/case>
&lt;/node-factory></font></code></pre>

<p>Alternatively, custom state can be stored as arbitrary key-value pairs without extending the persistent state element.
All of the system-provided state element types include an Attributes property for this purpose. To make it easier to
work with the Attributes property, methods are provided to read and write attributes by name. These methods leverage
<a href="../../services/ConversionService.html">all conversions known to Sapphire</a>, so it is typically not necessary
to manually convert the values to and from a string.</p>

<p>This approach should only be used in situations when extending the persistent state element is not practical
or possible. State stored as attributes is harder to access. For instance, unlike actual properties, attributes
cannot be directly accessed from EL.</p>

<p style="margin-left: 20px;"><b>Example</b></p>

<p style="margin-left: 20px;">In the catalog sample, a toggle action controls whether the catalog items
are color-coded by manufacturer. The state of this toggle is persisted as an attribute.</p>

<pre class="source-code"><code>public final class ShowManufacturerColorActionHandler extends SapphireActionHandler 
{
    public static final String ATTRIBUTE = "ColorCode";

    private CatalogEditorPageState state;

    @Override
    public void init( final SapphireAction action, final ActionHandlerDef def )
    {
        super.init( action, def );

        this.state = (CatalogEditorPageState) getPart().nearest( SapphireEditorPagePart.class ).state();

        final Listener listener = new FilteredListener&lt;PropertyContentEvent>()
        {
            @Override
            protected void handleTypedEvent( final PropertyContentEvent event )
            {
                setChecked( ShowManufacturerColorActionHandler.this.state.getAttribute( ATTRIBUTE, false ) );
            }
        };

        this.state.attach( listener, CatalogEditorPageState.PROP_ATTRIBUTES.getName() + "/*" );

        setChecked( this.state.getAttribute( ATTRIBUTE, false ) );

        attach
        (
            new FilteredListener&lt;DisposeEvent>()
            {
                @Override
                protected void handleTypedEvent( final DisposeEvent event )
                {
                    ShowManufacturerColorActionHandler.this.state.detach( listener, CatalogEditorPageState.PROP_ATTRIBUTES.getName() + "/*" );
                }
            }
        );
    }

    @Override
    protected Object run( final SapphireRenderingContext context )
    {
        this.state.setAttribute( ATTRIBUTE, ! this.state.getAttribute( ATTRIBUTE, false ) );

        return null;
    }
}</code></pre>

<p style="margin-left: 20px;">The toggle action and its handler are defined in sdef.</p>

<pre class="source-code"><code><font color="#888888">&lt;editor-page></font>
    &lt;action>
        &lt;id>Sample.ShowManufacturerColor&lt;/id>
        &lt;label>Color Code Manufacturers&lt;/label>
        &lt;image>ItemPurple.png&lt;/image>
        &lt;type>TOGGLE&lt;/type>
        &lt;context>Sapphire.EditorPage&lt;/context>
        &lt;location>after:Sample.ShowManufacturer&lt;/location>
        &lt;location>before:Sapphire.Outline.Hide&lt;/location>
    &lt;/action>
    &lt;action-handler>
        &lt;action>Sample.ShowManufacturerColor&lt;/action>
        &lt;id>Sample.ShowManufacturerColor&lt;/id>
        &lt;impl>ShowManufacturerColorActionHandler&lt;/impl>
    &lt;/action-handler>
<font color="#888888">&lt;/editor-page></font></code></pre>

<p style="margin-left: 20px;">A custom EL function is used to read the state attribute and to derive a color code item image
based on the manufacturer.</p>

<pre class="source-code"><code>public final class ItemImageFunction extends Function
{
    private final ImageData IMAGE_GENERIC = ImageData.createFromClassLoader( ItemImageFunction.class, "Item.png" );

    private final ImageData[] IMAGES =
    {
        ImageData.createFromClassLoader( ItemImageFunction.class, "ItemBlue.png" ),
        ImageData.createFromClassLoader( ItemImageFunction.class, "ItemGreen.png" ),
        ImageData.createFromClassLoader( ItemImageFunction.class, "ItemOrange.png" ),
        ImageData.createFromClassLoader( ItemImageFunction.class, "ItemPurple.png" ),
        ImageData.createFromClassLoader( ItemImageFunction.class, "ItemRed.png" ),
        ImageData.createFromClassLoader( ItemImageFunction.class, "ItemTurquoise.png" ),
        ImageData.createFromClassLoader( ItemImageFunction.class, "ItemYellow.png" )
    };

    @Override
    public String name()
    {
        return "CatalogItemImage";
    }

    @Override
    public FunctionResult evaluate( final FunctionContext context )
    {
        if( context instanceof PartFunctionContext )
        {
            final SapphirePart part = ( (PartFunctionContext) context ).part();
            final MasterDetailsEditorPagePart page = part.nearest( MasterDetailsEditorPagePart.class );

            if( page != null )
            {
                final IModelElement element = part.getLocalModelElement();

                if( element instanceof Item )
                {
                    final Item item = (Item) element;
                    final MasterDetailsEditorPageState state = page.state();

                    return new FunctionResult( this, context )
                    {
                        private Listener listener;

                        @Override
                        protected void init()
                        {
                            this.listener = new FilteredListener&lt;PropertyContentEvent>()
                            {
                                @Override
                                protected void handleTypedEvent( final PropertyContentEvent event )
                                {
                                    refresh();
                                }
                            };

                            state.attach( this.listener, MasterDetailsEditorPageState.PROP_ATTRIBUTES.getName() + "/*" );
                            element.attach( this.listener, Item.PROP_MANUFACTURER );
                        }

                        @Override
                        protected Object evaluate()
                        {
                            final boolean color = state.getAttribute( ShowManufacturerColorActionHandler.ATTRIBUTE, false );

                            if( color )
                            {
                                final String manufacturer = item.getManufacturer().getContent();
                                final int hashCode = ( manufacturer == null ? 0 : manufacturer.hashCode() );
                                final int index = abs( hashCode ) % IMAGES.length;

                                return IMAGES[ index ];
                            }
                            else
                            {
                                return IMAGE_GENERIC;
                            }
                        }

                        @Override
                        public void dispose()
                        {
                            super.dispose();

                            if( this.listener != null )
                            {
                                state.detach( this.listener, MasterDetailsEditorPageState.PROP_ATTRIBUTES.getName() + "/*" );
                                element.detach( this.listener, Item.PROP_MANUFACTURER );

                                this.listener = null;
                            }
                        }
                    };
                }
            }
        }

        throw new FunctionException( "CatalogItemImage() function cannot be used in this context.");
    }
}</code></pre>

<p style="margin-left: 20px;">The CatalogItemImage() function is registered as a Sapphire extension.</p>

<pre class="source-code"><code><font color="#888888">&lt;extension></font>
    &lt;function>
        &lt;name>CatalogItemImage&lt;/name>
        &lt;impl>org.eclipse.sapphire.samples.catalog.ItemImageFunction&lt;/impl>
    &lt;/function>
<font color="#888888">&lt;/extension></font></code></pre>

<p style="margin-left: 20px;">Finally, the content outline node image for a catalog item is defined using a simple expression 
that references the CatalogItemImage() function.</p>

<pre class="source-code"><code><font color="#888888">&lt;node-factory>
    &lt;property>Items&lt;/property>
    &lt;case>
        &lt;image></font>${ CatalogItemImage() }<font color="#888888">&lt;/image>
    &lt;/case>
&lt;/node-factory></font></code></pre>


<h2><a name="Core"><a name="Core-ModelElement">ModelElement</a></a></h2>

<p>A facility to copy all properties of one element to another element existed in previous releases. Now a facility to 
copy individual properties is also available.</p>

<pre class="source-code"><code><font color="#888888">IModelElement
{
    void copy( IModelElement element )</font>
    void copy( IModelElement element, ModelProperty property )
    void copy( IModelElement element, String property )
<font color="#888888">}</font></code></pre>

<p>Clear one property or all of them using the new methods.</p>

<pre class="source-code"><code><font color="#888888">IModelElement
{</font>
    void clear()
    void clear( ModelProperty property )
    void clear( String property )
<font color="#888888">}</font></code></pre>


<h2><a name="Core-ModelElementHandle">ModelElementHandle</a></h2>

<p>Among objects returned by property getters (Value, Transient, ModelElementHandle and ModelElementList),
ModelElementHandle was the only one that had no API to retrieve the parent property.</p>

<pre class="source-code"><code><font color="#888888">ModelElementHandle
{</font>
    ElementProperty property()
<font color="#888888">}</font></code></pre>

<p>For convenience, type can be specified using the type's class to avoid having to cast the result.</p>

<pre class="source-code"><code><font color="#888888">ModelElementHandle
{
    T element()
    T element( boolean createIfNecessary )
    T element( boolean createIfNecessary, ModelElementType type )</font>
    &lt;C extends IModelElement> C element( boolean createIfNecessary, Class&lt;C> cl )
<font color="#888888">}</font></code></pre>


<h2><a name="Core-RequiredConstraintService">RequiredConstraintService</a></h2>

<p><a href="../../services/RequiredConstraintService.html">RequiredConstraintService</a> determines whether a value or 
an element property is required to have content. Most frequently specified via an @Required annotation, which
<a href="#ExpressionLanguage-UseInRequired">now supports EL</a> for specifying custom semantics.</p>

<p style="margin-left: 20px;"><b>Example</b></p>

<pre class="source-code"><code>public class CustomRequiredConstraintService extends RequiredConstraintService
{
    @Override
    protected void initRequiredConstraintService()
    {
        // Optionally register listeners to invoke refresh method when the required constraint
        // may need to be updated.
    }

    @Override
    protected Boolean compute()
    {
        ...
    }

    @Override
    public void dispose()
    {
        super.dispose();

        // Remove any listeners that were added during initialization.
    }
}</code></pre>

<pre class="source-code"><code>@Service( impl = CustomRequiredConstraintService.class )

<font color="#888888">ValueProperty PROP_CATEGORY = new ValueProperty( TYPE, "Category" );

Value&lt;String> getCategory();
void setCategory( String value );</font></code></pre>


<h2><a name="Core-RootServiceContext">Root Service Context</a></h2>

<p>Certain types of services, such as many ConversionService implementations, are useful across
different service contexts. Services that are part of the new root service context are visible to
all other contexts.</p>

<pre class="source-code"><code><font color="#888888">Sapphire
{</font>
    static &lt;S extends Service> S service( Class&lt;S> type )
    static &lt;S extends Service> List&lt;S> services( Class&lt;S> type )
    static synchronized ServiceContext services()
<font color="#888888">}</font></code></pre>

<pre class="source-code"><code><font color="#888888">Integer number =</font> Sapphire.service( MasterConversionService.class )<font color="#888888">.convert( "123", Integer.class );</font></code></pre>

<pre class="source-code"><code><font color="#888888">&lt;extension xmlns="http://www.eclipse.org/sapphire/xmlns/extension">
    &lt;service>
        &lt;id>Sapphire.ConversionService.StringToInteger&lt;/id>
        &lt;description>ConversionService implementation for String to Integer conversions.&lt;/description>
        &lt;implementation>org.eclipse.sapphire.internal.StringToIntegerConversionService&lt;/implementation></font>
        &lt;context>Sapphire&lt;/context>
    <font color="#888888">&lt;/service>
&lt;/extension></font></code></pre>


<h2><a name="Core-ServiceRegistrationWithoutFactory">Service Registration Without a Factory</a></h2>

<p>Registering services through Sapphire extension system has been made even easier by removing the
need to implement a ServiceFactory for services that do not require custom applicability logic. The
service implementation class can be specified directly.</p> 

<pre class="source-code"><code><font color="#888888">&lt;extension xmlns="http://www.eclipse.org/sapphire/xmlns/extension">
    &lt;service>
        &lt;id>Sapphire.ConversionService.StringToInteger&lt;/id>
        &lt;description>ConversionService implementation for String to Integer conversions.&lt;/description></font>
        &lt;implementation>org.eclipse.sapphire.internal.StringToIntegerConversionService&lt;/implementation>
        <font color="#888888">&lt;context>Sapphire&lt;/context>
    &lt;/service>
&lt;/extension></font></code></pre>


<h2><a name="Core-NewConversions">New Conversions</a></h2>

<p>The set of available conversions has been expanded. The new conversions can be used in a variety of contexts that 
draw upon  <a href="../../services/ConversionService.html">ConversionService</a> implementations, such as when using
<a href="../../services/MasterConversionService.html">MasterConversionService</a> or ModelElement.adapt() API.</p> 

<table>
  <tr>
    <th>Source</th>
    <th>Target</th>
  </tr>
  <tr>
    <td>org.eclipse.sapphire.modeling.ModelElement</td>
    <td>org.w3c.dom.Document</td>
  </tr>
  <tr>
    <td>org.eclipse.sapphire.modeling.ModelElement</td>
    <td>org.w3c.dom.Element</td>
  </tr>
  <tr>
    <td>org.eclipse.sapphire.modeling.ModelElement</td>
    <td>org.eclipse.sapphire.modeling.xml.XmlElement</td>
  </tr>
  <tr>
    <td>org.eclipse.sapphire.modeling.xml.XmlResource</td>
    <td>org.w3c.dom.Document</td>
  </tr>
  <tr>
    <td>org.eclipse.sapphire.modeling.xml.XmlResource</td>
    <td>org.w3c.dom.Element</td>
  </tr>
  <tr>
    <td>org.eclipse.sapphire.modeling.xml.XmlResource</td>
    <td>org.eclipse.sapphire.modeling.xml.XmlElement</td>
  </tr>
  <tr>
    <td>java.lang.String</td>
    <td>org.eclipse.sapphire.java.JavaIdentifier</td>
  </tr>
</table>


<h2><a name="ExpressionLanguage"><a name="ExpressionLanguage-UseForValidation">Use EL for Validation</a></a></h2>

<p>Use EL to specify validation rules.</p>

<p style="margin-left: 20px;"><b>Example</b></p>

<pre class="source-code"><code><font color="#888888">@Type( base = BigDecimal.class )</font>
    
@Validation
(
    rule = "${ Scale( Discount, 2 ) &lt;= Scale( Subtotal, 2 ) + Scale( Delivery, 2 ) }",
    message = "Discount must not exceed subtotal plus delivery charge."
)

<font color="#888888">ValueProperty PROP_DISCOUNT = new ValueProperty( TYPE, "Discount" );

Value&lt;BigDecimal> getDiscount();
void setDiscount( String value );
void setDiscount( BigDecimal value );</font></code></pre>


<h2><a name="ExpressionLanguage-UseInRequired">Use EL in @Required</a></h2>

<p>Use EL in the @Required annotation to define custom semantics.</p>

<p style="margin-left: 20px;"><b>Example</b></p>

<p style="margin-left: 20px;">In this example, the Category property is required only if the Version property is in the given range.</p> 

<pre class="source-code"><code>@Required( "${ VersionMatches( Version, '[1.0-2.1)' ) }" )

<font color="#888888">ValueProperty PROP_CATEGORY = new ValueProperty( TYPE, "Category" );

Value&lt;String> getCategory();
void setCategory( String value );</font></code></pre>


<h2><a name="ExpressionLanguage-EnabledFunction">Enabled Function</a></h2>

<p>In the context of a property editor, specifying property name when using Enabled() function can be redundant,
so a zero argument version of the function is now available, but only for the property editor context.</p>

<p style="margin-left: 20px;"><b>Example</b></p>

<pre class="source-code"><code><font color="#888888">&lt;property-editor>
    &lt;property>FormLoginPage&lt;/property>
    &lt;visible-when></font>${ Enabled() }<font color="#888888">&lt;/visible-when>
&lt;/property-editor></font></code></pre>


<h2><a name="ExpressionLanguage-OperandScopedFunctions">Operand-Scoped Function</a></h2>

<p>Sapphire EL functions are registered by name and the same function can take an arbitrary number of operands. In certain
cases, it is useful to direct different operand counts to different implementations. To that end, it is now possible to
constraint which operand counts a particular function definition applies to. Absent the constraint, a function definition
still applies to all operand counts.</p>

<p style="margin-left: 20px;"><b>Example</b></p>

<pre class="source-code"><code><font color="#888888">&lt;extension xmlns="http://www.eclipse.org/sapphire/xmlns/extension">
    &lt;function>
        &lt;name>Enabled&lt;/name></font>
        &lt;operand-count>1&lt;/operand-count>
        &lt;operand-count>2&lt;/operand-count>
        <font color="#888888">&lt;impl>org.eclipse.sapphire.modeling.el.EnabledFunction&lt;/impl>
    &lt;/function>
&lt;/extension></font></code></pre>

<pre class="source-code"><code><font color="#888888">&lt;extension xmlns="http://www.eclipse.org/sapphire/xmlns/extension">
    &lt;function>
        &lt;name>Enabled&lt;/name></font>
        &lt;operand-count>0&lt;/operand-count>
        <font color="#888888">&lt;impl>org.eclipse.sapphire.ui.internal.PropertyEditorEnabledFunction&lt;/impl>
    &lt;/function>
&lt;/extension></font></code></pre>


<h2><a name="ExpressionLanguage-StateFunction">State Function</a></h2>

<p>Returns the root element of editor page's persistent state, allowing access to various state properties. This is
particularly useful when the persistent state is extended with custom properties wired to custom actions, as it allows
any EL-enabled facility to integrate with the custom state property.</p>

<p style="margin-left: 20px;"><b>Example</b></p>

<p style="margin-left: 20px;">In this example, a custom state property is used to control whether content outline node label for an item
in the catalog sample should include the manufacturer.</p>

<pre class="source-code"><code><font color="#888888">&lt;node-factory>
    &lt;property>Items&lt;/property>
    &lt;case>
        &lt;label></font>${ Name == null ? &quot;&lt;item&gt;&quot; : ( State().ShowManufacturer &amp;&amp; Manufacturer != null ? Concat( Manufacturer, &quot; &quot;, Name ) : Name ) }<font color="#888888">&lt;/label>
    &lt;/case>
&lt;/node-factory></font></code></pre>


<h2><a name="Forms"><a name="Forms-SectionReference">Section Reference</a></a></h2>

<p>Re-use section definitions across multiple node definitions in a master-details editor page.</p>

<p style="margin-left: 20px;"><b>Example</b></p>

<pre class="source-code"><code><font color="#888888">&lt;definition></font>
    &lt;section>
        &lt;id>CommonSection&lt;/id>
        &lt;label>common&lt;/label>
        &lt;content>
            ...
        &lt;/content>
    &lt;/section>
    <font color="#888888">&lt;node>
        &lt;id>Node-1&lt;/id>
        &lt;label>node 1&lt;/label></font>
        &lt;section-ref>CommonSection&lt;/section-ref>
        <font color="#888888">&lt;section>
            &lt;label>another section&lt;/label>
            &lt;content>
                ...
            &lt;/content>
        &lt;/section>
    &lt;/node>
    &lt;node>
        &lt;id>Node-2&lt;/id>
        &lt;label>node 2&lt;/label></font>
        &lt;section-ref>CommonSection&lt;/section-ref>
        <font color="#888888">&lt;section>
            &lt;label>another section&lt;/label>
            &lt;content>
                ...
            &lt;/content>
        &lt;/section>
    &lt;/node>
&lt;/definition></font></code></pre>


<h2><a name="Forms-ColorBrowsing">Color Browsing</a></h2>

<p>Define a color value property using the provided Color type and Sapphire will supply browse support.</p>

<p style="margin-left: 20px;"><b>Example</b></p>

<pre class="source-code"><code><font color="#888888">@Type( base =</font> Color<font color="#888888">.class )

ValueProperty PROP_COLOR = new ValueProperty( TYPE, "Color" );
    
Value&lt;</font>Color<font color="#888888">> getColor();
void setColor( String value );
void setColor(</font> Color <font color="#888888">value );
</font></code></pre>

<p style="margin-left: 20px;"><img src="images/ColorBrowsing.png"/></p>


<h2><a name="Miscellaneous"><a name="Miscellaneous-JavaIdentifier">JavaIdentifier</a></a></h2>

<p>The JavaIdentifier class can be used to represent a legal Java identifier, such as the name of a variable,
a field or a method. Identifiers must conform to <nobr>[a-zA-Z_$][a-zA-Z0-9_$]*</nobr> pattern.</p>

<p>Verification happens in the constructor, so any instance can be assumed
to represent a valid identifier. This class can be used by itself or as a type of a value property.</p>

<p style="margin-left: 20px;"><b>Example</b></p>

<pre class="source-code"><code><font color="#888888">@Type( base =</font> JavaIdentifier.class <font color="#888888">)

ValueProperty PROP_FIELD_NAME = new ValueProperty( TYPE, "FieldName" );

Value&lt;</font>JavaIdentifier<font color="#888888">> getFieldName();
void setFieldName( String value );
void setFieldName(</font> JavaIdentifier <font color="#888888">value );</font></code></pre>


<div class="copyright">Copyright (c) 2013 Oracle<br/>
Content made available under the terms of <a href="http://www.eclipse.org/legal/epl-v10.html">Eclipse Public License</a>.</div>

</body>

</html>
